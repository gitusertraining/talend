package routines;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.commons.lang3.StringUtils;

/*
 * user specification: the function's comment should contain keys as follows: 1. write about the function's comment.but
 * it must be before the "{talendTypes}" key.
 * 
 * 2. {talendTypes} 's value must be talend Type, it is required . its value should be one of: String, char | Character,
 * long | Long, int | Integer, boolean | Boolean, byte | Byte, Date, double | Double, float | Float, Object, short |
 * Short
 * 
 * 3. {Category} define a category for the Function. it is required. its value is user-defined .
 * 
 * 4. {param} 's format is: {param} <type>[(<default value or closed list values>)] <name>[ : <comment>]
 * 
 * <type> 's value should be one of: string, int, list, double, object, boolean, long, char, date. <name>'s value is the
 * Function's parameter name. the {param} is optional. so if you the Function without the parameters. the {param} don't
 * added. you can have many parameters for the Function.
 * 
 * 5. {example} gives a example for the Function. it is optional.
 */
public class SQLBuilder {
	public static String getDriverClass(Map<String, Object> globalMap) {
		DBType type = DBType.of(globalMap.get("sourceType"));

		String driverClass = "";
		switch (type) {
		case ORACLE:
			driverClass = "oracle.jdbc.driver.OracleDriver";
			break;
		case SQLSERVER:
			driverClass = "com.microsoft.sqlserver.jdbc.SQLServerDriver";
			break;
		case MYSQL:
			driverClass = "com.mysql.jdbc.Driver";
			break;
		default:

		}

		return driverClass;
	}

	public static String buildCountSQL(Map<String, Object> globalMap, List<ResourcePathFilter> list) {
		DBType type = DBType.of(globalMap.get("sourceType"));

		switch (type) {
		case ORACLE:
			return OracleSQLBuilder.buildCountSQL(globalMap, list);
		default:
			return buildCountSQLFromSource(globalMap, list);
		}
	}

	public static String buildCountSQLFromSource(Map<String, Object> globalMap, List<ResourcePathFilter> list) {
		StringBuilder countSQLBuilder = new StringBuilder();

		String withClause = getWithClause(globalMap);
		if (!Utils.isBlank(withClause)) {
			countSQLBuilder.append(withClause).append(" ");
		}
		countSQLBuilder.append("SELECT COUNT(1) FROM ").append(getSourceObject(globalMap));
		countSQLBuilder.append(getWhereClause(globalMap, list));
		return countSQLBuilder.toString();
	}

	public static String buildSelectSQL(Map<String, Object> globalMap, List<ResourcePathFilter> list) {
		DBType type = DBType.of(globalMap.get("sourceType"));

		switch (type) {
		case ORACLE:
			return OracleSQLBuilder.buildSelectSQL(globalMap, list);
		case SQLSERVER:
			return MSSQLBuilder.buildSelectSQL(globalMap, list);
		case MYSQL:
			return MySQLBuilder.buildSelectSQL(globalMap, list);
		default:
			return OracleSQLBuilder.buildSelectSQL(globalMap, list);
		}
	}

	public static String buildPaginationSQL(Map<String, Object> globalMap, List<ResourcePathFilter> list) {
		DBType type = DBType.of(globalMap.get("sourceType"));

		switch (type) {
		case ORACLE:
			return OracleSQLBuilder.buildPaginationSQL(globalMap, list);
		case SQLSERVER:
			return MSSQLBuilder.buildPaginationSQL(globalMap, list);
		case MYSQL:
			return MySQLBuilder.buildPaginationSQL(globalMap, list);
		default:
			return OracleSQLBuilder.buildPaginationSQL(globalMap, list);
		}
	}

	public static String buildLimitSQL(Map<String, Object> globalMap, List<ResourcePathFilter> list) {
		DBType type = DBType.of(globalMap.get("sourceType"));

		switch (type) {
		case ORACLE:
			return OracleSQLBuilder.buildLimitSQL(globalMap, list);
		case SQLSERVER:
			return MSSQLBuilder.buildLimitSQL(globalMap, list);
		case MYSQL:
			return MySQLBuilder.buildLimitSQL(globalMap, list);
		default:
			return OracleSQLBuilder.buildLimitSQL(globalMap, list);
		}
	}

	public static Object parseFilterValue(List<String> values, String type) {
		if (DBConnector.FIELD_TYPE_LIST.equalsIgnoreCase(type)) {
			List<String> temp = new ArrayList<String>();
			for (String val : values) {
				if (Utils.isBlank(val)) {
					continue;
				}

				for (String str : val.split(",")) {
					temp.add(str == null ? StringUtils.EMPTY : str.trim());
				}
			}
			return temp;
		} else {
			String str = values.get(0);
			return str == null ? StringUtils.EMPTY : str.trim();
		}

	}

	static String getWithClause(Map<String, Object> globalMap) {
		return getStringValue(globalMap, "withClause");
	}

	static String getSourceObject(Map<String, Object> globalMap) {
		return getStringValue(globalMap, "sourceObjects");
	}

	static String getResourceFields(Map<String, Object> globalMap) {
		Object obj = globalMap.get("resourceFields");
		return obj == null ? "*" : (String) obj;
	}

	static String getSortExpression(Map<String, Object> globalMap) {
		Object sortExpressionObj = globalMap.get("sortExpression");
		Object reqSortingObj = globalMap.get("reqSorting");

		List<String> sortingList = new ArrayList<String>();
		if (sortExpressionObj != null) {
			addSortingField(sortingList, (String) sortExpressionObj);
		}

		if (reqSortingObj != null) {
			String[] sortings = ((String) reqSortingObj).split(",");
			for (String sorting : sortings) {
				if (Utils.isBlank(sorting)) {
					continue;
				}

				if (sorting.startsWith("+")) {
					addSortingField(sortingList, sorting.substring(1));
				} else if (sorting.startsWith("-")) {
					addSortingField(sortingList, sorting.substring(1), true);
				} else {
					addSortingField(sortingList, sorting);
				}
			}
		}

		return sortingList.size() == 0 ? StringUtils.EMPTY : " ORDER BY " + String.join(",", sortingList);
	}

	static void addSortingField(List<String> sortingList, String sorting) {
		addSortingField(sortingList, sorting, false);
	}

	static void addSortingField(List<String> sortingList, String sorting, boolean isDescSpecified) {
		if (Utils.isBlank(sorting)) {
			return;
		}

		String temp = sorting.trim();
		if (isDescSpecified) {
			sortingList.add(temp.concat(" DESC"));
		} else {
			sortingList.add(temp);
		}

	}

	static String getStringValue(Map<String, Object> globalMap, String key) {
		Object obj = globalMap.get(key);
		return obj == null ? StringUtils.EMPTY : (String) obj;
	}

	static String getWhereClause(Map<String, Object> globalMap, List<ResourcePathFilter> list) {
		int index = 1;
		StringBuilder whereCluaseBuilder = new StringBuilder(" WHERE 1=1");

		Object reqIdentity = globalMap.get("reqIdentity");
		Object resIdentity = globalMap.get("resIdentity");
		if (reqIdentity != null && resIdentity != null) {
			whereCluaseBuilder.append(" AND ").append(resIdentity).append(" = ?");
			list.add(new ResourcePathFilter("reqIdentity", reqIdentity, DBConnector.FIELD_TYPE_STRING, index++));
		}

		whereCluaseBuilder.append(getFilterExpressions(globalMap, list, index));
		return whereCluaseBuilder.toString();
	}

	@SuppressWarnings("unchecked")
	private static String getFilterExpressions(Map<String, Object> globalMap, List<ResourcePathFilter> list,
			int index) {
		Object filterExpressions = globalMap.get("filterExpressions");
		if (filterExpressions == null) {
			return StringUtils.EMPTY;
		}

		StringBuilder builder = new StringBuilder();
		Object tempObj = globalMap.get("PARSED_FILTERS");
		Map<String, ResourcePathFilter> parsedFilters = (tempObj == null ? null
				: (Map<String, ResourcePathFilter>) tempObj);
		for (KV kv : (List<KV>) filterExpressions) {
			String expression = (String) kv.getValue();
			if (Utils.isBlank(kv.getKey())) {
				and(builder, expression);
			} else {
				// Handler Dynamic filter
				String filterName = kv.getKey().toUpperCase();
				// Filter is not specified in request
				if (parsedFilters == null || !parsedFilters.containsKey(filterName)) {
					continue;
				}

				// Find request path parameter
				ResourcePathFilter filter = parsedFilters.get(filterName);
				if (DBConnector.FIELD_TYPE_LIST.equals(filter.getType())) {
					// Handler List parameters
					List<String> values = (List<String>) filter.getValue();
					if (values == null || values.size() <= 0) {
						continue;
					}

					and(builder, expression.replace("?", buildPlaceholderForList(values.size())));
					for (String value : values) {
						list.add(new ResourcePathFilter(filterName, value, DBConnector.FIELD_TYPE_STRING, index++));
					}
				} else {
					and(builder, expression);
					Object value = filter.getValue();
					if (value != null && isFuzzyMode(expression)
							&& DBConnector.FIELD_TYPE_STRING.equalsIgnoreCase(filter.getType())) {
						value = toSqlWildcardString((String) value);
					}
					list.add(new ResourcePathFilter(filterName, value, filter.getType(), index++));
				}
			}
		}
		return builder.toString();
	}

	static boolean isFuzzyMode(String expression) {
		return expression != null && expression.toLowerCase().contains(" like ");
	}

	static String toSqlWildcardString(String value) {
//      if (value.contains("\\")) {
//          value = value.replaceAll("\\\\", "\\\\\\\\");
//      }
//      if (value.contains("_")) {
//          value = value.replaceAll("_", "\\\\_");
//      }
//      if (value.contains("%")) {
//          value = value.replaceAll("%", "\\\\%");
//      }

		value = value.replaceAll("\\*", "%");
		return value;
	}

	@SuppressWarnings("unchecked")
	@Deprecated
	private static String getDynamicFilterExpressions(Map<String, Object> globalMap, List<ResourcePathFilter> list,
			int index) {
		Object dynamicFilterExpressions = globalMap.get("dynamicFilterExpressions");
		if (dynamicFilterExpressions == null) {
			return StringUtils.EMPTY;
		}

		StringBuilder builder = new StringBuilder();
		Map<String, ResourcePathFilter> parsedFilters = (Map<String, ResourcePathFilter>) globalMap
				.get("PARSED_FILTERS");
		for (Entry<String, String> entry : ((Map<String, String>) dynamicFilterExpressions).entrySet()) {
			String filterName = entry.getKey().toUpperCase();
			if (!parsedFilters.containsKey(filterName)) {
				continue;
			}

			ResourcePathFilter filter = parsedFilters.get(filterName);
			if (DBConnector.FIELD_TYPE_LIST.equals(filter.getType())) {
				List<String> values = (List<String>) filter.getValue();
				if (values == null || values.size() <= 0) {
					continue;
				}

				and(builder, entry.getValue().replace("?", buildPlaceholderForList(values.size())));
				for (String value : values) {
					list.add(new ResourcePathFilter(filterName, value, DBConnector.FIELD_TYPE_STRING, index++));
				}
			} else {
				and(builder, entry.getValue());
				list.add(new ResourcePathFilter(filterName, filter.getValue(), filter.getType(), index++));
			}
		}
		return builder.toString();
	}

	static void and(StringBuilder builder, String expression) {
		builder.append(" AND ").append(expression);
	}

	static String buildPlaceholderForList(int size) {
		if (size <= 0) {
			return StringUtils.EMPTY;
		}

		StringBuilder builder = new StringBuilder("(");
		for (int i = 0; i < size; i++) {
			if (i == (size - 1)) {
				builder.append("?)");
			} else {
				builder.append("?,");
			}
		}
		return builder.toString();
	}

	public static enum DBType {
		ORACLE("ORACLE"), SQLSERVER("SQLSERVER"), MYSQL("MYSQL");

		private String value;

		private DBType(String value) {
			this.value = value;
		}

		public static DBType of(Object value) {
			if (value == null) {
				return null;
			}

			String str = (String) value;
			if (Utils.isBlank(str)) {
				return null;
			}

			for (DBType type : values()) {
				if (type.value.equalsIgnoreCase(str.replaceAll("\\s", ""))) {
					return type;
				}
			}

			return null;

		}
	}
}
