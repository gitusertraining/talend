package routines;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/*
 * user specification: the function's comment should contain keys as follows: 1. write about the function's comment.but
 * it must be before the "{talendTypes}" key.
 * 
 * 2. {talendTypes} 's value must be talend Type, it is required . its value should be one of: String, char | Character,
 * long | Long, int | Integer, boolean | Boolean, byte | Byte, Date, double | Double, float | Float, Object, short |
 * Short
 * 
 * 3. {Category} define a category for the Function. it is required. its value is user-defined .
 * 
 * 4. {param} 's format is: {param} <type>[(<default value or closed list values>)] <name>[ : <comment>]
 * 
 * <type> 's value should be one of: string, int, list, double, object, boolean, long, char, date. <name>'s value is the
 * Function's parameter name. the {param} is optional. so if you the Function without the parameters. the {param} don't
 * added. you can have many parameters for the Function.
 * 
 * 5. {example} gives a example for the Function. it is optional.
 */
/**
 * EQUALS: 'eq', AND: 'and', OR: 'or', GREATER_THAN: 'gt', GREATER_THAN_EQUAL:
 * 'ge', LESS_THAN: 'lt', LESS_THAN_EQUAL: 'le', LIKE: 'like', IS_NULL: 'is
 * null', NOT_EQUAL: 'ne',
 *
 */
public class FilterParser {
	static final Logger logger = LoggerFactory.getLogger(FilterParser.class);
	public static enum Operate {
		EQUALS(" eq "), AND(" and ");

		private String value;

		private Operate(String value) {
			this.value = value;
		}
	}

	public static Set<KV> parse(List<String> validList, String filter) {
		if (Utils.isBlank(filter) || validList == null || validList.isEmpty()) {
			return null;
		}

		String[] arr = filter.split(Operate.AND.value);
		if (arr == null || arr.length == 0) {
			logger.warn("Incorrect filter format: {}", filter);
			return null;
		}

		Set<KV> set = new HashSet<KV>();
		for (String str : arr) {
			if (Utils.isBlank(str)) {
				continue;
			}
			
			String[] arr2 = str.split(Operate.EQUALS.value);
			if (arr2 == null || arr2.length != 2 || Utils.isBlank(arr2[0]) || Utils.isBlank(arr2[1])) {
				logger.warn("Incorrect filter format: {}", str);
				continue;
			}
			
			String key = arr2[0].trim();
			String value = arr2[1].trim();
			logger.debug("Parsed filter key:{}, value:{}", key, value);
			if (validList.stream().anyMatch(key::equalsIgnoreCase)) {
				set.add(new KV(key, value));
			}
		}
		return set;
	}

	public static KV[] parse(String validString, String filter) {
		logger.debug("Configured filter string: {}, Request filter string: {}", validString, filter);
		if (Utils.isBlank(validString) || Utils.isBlank(filter)) {
			return null;
		}

		Set<KV> set = parse(Arrays.asList(StringUtils.split(validString, ",")), filter);
		return set.toArray(new KV[0]);
	}

	/**
	 * helloExample: not return value, only print "hello" + message.
	 * 
	 * 
	 * {talendTypes} String
	 * 
	 * {Category} User Defined
	 * 
	 * {param} string("world") input: The string need to be printed.
	 * 
	 * {example} helloExemple("world") # hello world !.
	 */
	public static void helloExample(String message) {
		if (message == null) {
			message = "World"; //$NON-NLS-1$
		}
		System.out.println("Hello " + message + " !"); //$NON-NLS-1$ //$NON-NLS-2$
	}
}
